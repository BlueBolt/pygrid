
#    (c)2011 Bluebolt Ltd.  All rights reserved.
#    
#    Redistribution and use in source and binary forms, with or without
#    modification, are permitted provided that the following conditions are
#    met:
#    * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following disclaimer
#    in the documentation and/or other materials provided with the
#    distribution.
#    * Neither the name of Bluebolt nor the names of
#    its contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#    
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#    
#    Author:Ashley Retallack - ashley-r@blue-bolt.com
#    Created:2011-06-07


'''
    main gridengine submission class
'''
import os as _os
import sys as _sys
import socket
try:
    import faulthandler
    faulthandler.enable(_sys.__stderr__)
except:
    print "Unable to load faulthandler , carrying on ..."
    

from subprocess import Popen as _Popen
from subprocess import PIPE as _PIPE

from . import version_api,mkfolder

from Task import Task
from Queue import Queue
from User import User
from ParallelEnvironment import ParallelEnvironment
from Exceptions import *
from version import version as pygrid_version

import sql_gridengine as _sql_ge

import datetime

import drmaa as _drmaa

t_stdout= _sys.__stdout__
t_stderr= _sys.__stderr__

decodestatus = {
    _drmaa.JobState.UNDETERMINED: 'unknown',
    _drmaa.JobState.QUEUED_ACTIVE: 'queued',
    _drmaa.JobState.SYSTEM_ON_HOLD: 'queued',
    _drmaa.JobState.USER_ON_HOLD: 'paused',
    _drmaa.JobState.USER_SYSTEM_ON_HOLD: 'paused',
    _drmaa.JobState.RUNNING: 'running',
    _drmaa.JobState.SYSTEM_SUSPENDED: 'suspended',
    _drmaa.JobState.USER_SUSPENDED: 'suspended',
    _drmaa.JobState.DONE: 'finished',
    _drmaa.JobState.FAILED: 'failed',
}

class JobType(object):
        '''
            Enum for the type of Job class, 

            @ Root :- has not grid job, just the root job that contains other jobs 
            @ ARRAY :- Job has multiple tasks below it
            @ Single :- a single task grid job
        '''
        ROOT=0
        ARRAY=1
        SINGLE=2

class Job(object):
    ''' 
        Main grid-engine job class        
    '''
    def __init__(self,jid=None):
        # super(Job, self).__init__()
        self.apiVersion = version_api    
        self._jid=None
        self._name='noName'  
        if isinstance(jid,int):
            self.jid = jid #: this jobs bb grid id (?)     
        elif isinstance(jid,str):          
            self.name = jid #: name as it will appear in gridengine/BB Grid # TODO get the id based on the name of the job

        self.label = 'noLabel' #: the label that appers at the front of the job in grid, and what will appear in the task box of bb_grid
        self.queue = Queue('all.q') #: Queue object instance
        self.dt = datetime.datetime.now() #: current date and time 
        self.date = str(datetime.date.today()) #: date as a nice string        
        self.priority = 0 #: range of -1024 -> 1024
        self.job_names = [] #: list of jobnames that this job creates
        self.jobids = [] #: list of grid engine job ids that this job hosts
               
        self.type = JobType.ROOT #: type of job can be a value of JopbTypeROOT:ARRAY:SINGLE
        self.script = None #: the main script that will be ran for this job/task these usually get generated by the sub-classes
        self.options = '' #: extra options for the GE, like setting resources etc see `man qsub`
        self.resources = {'hard':[],'soft':[]} #:resorces requested for this submission {'hard':[('resourcename',<value>)],'soft':[]}
        self.s_args = '' #: extra commandline arguments for the submitted program 
        
        self.cmd = ''        
        self.args = ''
        
        self.wd = ''
        if not _os.getenv('USER'): _os.environ['USER']='nobody'
        self._user = "" # user class contains information of allowence and email etc
        self.user = _os.getenv('USER') # user class contains information of allowence and email etc
        self.email = False
        self.paused = False
        self.max_slots = 15 #: Maximum slots on the farm this job can take up at any one time
        self.frames = '1-10' #: comma seperated list of frames that are to be subbmitted (only effect Array type jobs), e.g. "1-10,12-20" can contain steps using 'x' e.g. "1-10x2" render every other frame 1 to 10
        self.step = 5 #: in an array job the number of frames to do in each batch
        self.pe = ParallelEnvironment("render") #: Parallel Environment Object to render on
        self.cpus=1 #: number of threads to use to render
        self.envs={} #: dictionary of environments to apply to this job, format: {'VARIABLE':'VALUE'}
        self.paths={'log_path':'','scripts_path':''} #: paths that this job needs to know
        self.extra_data={} #: any extra data that will be saved to the database
        
        # old lecacy features
        
        self.start = 0
        self.end = 0        
        self.scripts={} 
        self.jobnames = list()
        self.dependency = None #: will be added to the dependecy_list (below) if not None
        
        # v1.0.* features 
        
        self.tasks = [] #: list of task objects        
        self.parent = None #: if this is a sub task relate the parent here
        self.children = [] #: list child job objects 
        self.dependency_list = [] #: jobs that this job depends on
        self.hosts = [] #: hosts to send this job to , returns a list of Host objects
        self.is_submitted = False #: returns true if this job has been submitted
        self.sessionid = None #: drmaa session id for this job submission
        self.portid = 8850 # default port for messenger (for sending updates and messages to the submitter)
        self.submit_host = socket.gethostbyname(socket.gethostname()) # the hosts that is submitting this job
        self.project = None #: Set the project that this job and it's tasks should be attached to
        
        self.ws = '' #: workspace for this job to output it's working files and logs
        
        if _os.environ.has_key('WORKSPACE_PATH') and _os.environ['WORKSPACE_PATH']:
            self.ws = _os.environ['WORKSPACE_PATH']
        
        # setup environment defaults
        self.getEnvs()
        
        if self.parent:
            self.dt = self.parent.dt
            self.date = self.parent.date
        
        # populate the job based on a given jobid (BB Grid)
        if self.jid:
            self.fillData(self.jid)
    
    # Properties
    def cpus():
        doc = "Number of threads to use to render this changed the slots value of any parallel environments"
        def fget(self):
            return self.pe.slots
        def fset(self, value):
            self.pe.slots = value
        return locals()
    cpus = property(**cpus())

    def user():
        doc = "Number of threads to use to render this changed the slots value of any parallel environments"
        def fget(self):
            return self._user
        def fset(self, value):
            if isinstance(value,User):
                self._user = value
            else:
                self._user = User(value)
        return locals()
    user = property(**user())

    def queue():
        doc = "Number of threads to use to render this changed the slots value of any parallel environments"
        def fget(self):
            return self._queue
        def fset(self, value):
            if isinstance(value,Queue):
                self._queue = value
            else:
                self._queue = Queue(value)
        return locals()
    queue = property(**queue())

    def name():
        doc = "The name property. is set will try and get the job from database and fill in jid etc"
        def fget(self):
            return self._name
        def fset(self, value):
            self._name = value

        return locals()
    name = property(**name())

    # TODO detect if jid is valid
    def jid():
        doc = "The jid property."
        def fget(self):
            return self._jid
        def fset(self, value):
            self._jid = value
        return locals()
    jid = property(**jid())

    @classmethod
    def fillData(self,jid):
        '''TODO given the grid job id gather and fill this instance with the details relevent to control 
        a finished or running job and it's tasks 
        '''
        
        # check that we are given an int to look-up

        if jid == None or not isinstance(jid,int):
            return

        # given the jid find this job in the database

        session=_sql_ge.alchemy_connect()
                
        # find the table that has this job in it
        table_exists=False
        shows = session.execute('''SHOW TABLES''')
        data = {}
        for (table_name,) in shows:
            if table_name.startswith('SHOW_'):
                result = session.execute( '''SELECT * FROM %s WHERE id=%d'''%(table_name,self.jid) )
                if int(result.rowcount) == 1:
                    table_exists=True
                    data = dict(zip(result.keys(),result.fetchall()[0]))

        for key,value in data.items():
            if isinstance(value,str) and len(value) and value[0] in ['{','[']:
                value=eval(value)

            if key == 'queue':
                value=Queue(value)
            if key == 'jobids':
                value=value.split(',')
            if key == 'user':
                value=User(value)
            if key == 'id': # we don't want to add the id again as we have allready got it from the creation of the job
                continue
            
            setattr(self,key,value)

        # add the tasks to this job
        self.tasks = []
        for jid in self.jobids:
            self.tasks.append(Task(jid))

        
        return jid
    
    def setCPUs(self,cpus):
        ''' set the numeber of cpus to use in the jobs parallel environment '''
                     
        self.pe.slots = cpus
    
    def submit(self,output='',test=False,rerun=False):
        ''' Main Submitter, loop over child job and runn thier submit commands in order of dependency '''
        
        print '-'*50
        print 'Submiting : ', self.label
        print 'PyGrid Version : ', pygrid_version
        
        if output:
            print output
        else:
            print self.output()
        
        # get dependencies

        array_dep_list = []         
        single_dep_list = [] 

        # append the legacy single dependecy if it exists
        if self.dependency != None and self.dependency not in self.dependency_list: 
            self.dependency_list.append(self.dependency)

        if len(self.dependency_list):

            for dependency in self.dependency_list:

                this_dep = dependency

                if this_dep and this_dep.type == JobType.ROOT:
                    this_dep = this_dep.children[-1]

                # Submit this dependency if it has not already been submitted
                this_dep.submit(test=test)                                        
                
                if this_dep and this_dep.jid:
                   
                    if this_dep.type is JobType.ARRAY and this_dep.frames == self.frames and self.type is JobType.ARRAY:

                        array_dep_list.append( '%s' % (this_dep.jobids[0].split('.')[0]) )

                    elif this_dep.type is JobType.ARRAY:
                        
                        single_dep_list.append( '%s' % (this_dep.jobids[0].split('.')[0]) ) 
                        
                    elif this_dep.type is JobType.SINGLE:

                        single_dep_list.append( '%s' % (this_dep.jobids[0]) )

                    elif this_dep.type is JobType.ROOT:

                        single_dep_list.append( '%s' % (this_dep.jobids[0]) )
        
        # get children
                
        child_jids = []
        child_tasks = []

        if len(self.children):
        
            # loop over children and submit them
        
            for child in self.children:
                if self.project: # set the childs project to same as the parent
                    child.project = self.project

                # enforce thet the top children of this job set their parent to the parent 
                # of this job if it is a root job and is part of a bigger connection

                if self.type is JobType.ROOT and len(self.dependency_list): 
                    for d in self.dependency_list:
                        if d not in child.dependency_list:
                            child.dependency_list.append(d)

                child.submit(test=test)  

                child_jids = child.jobids    
                child_tasks.append( child.tasks )    
                for j in child_jids:
                    self.jobids.append(j)

        # check if this job already has a jid and if this should be re-ran, 
        # if not just return it's list of job ids
        if self.jid and rerun == False:
            return self.jobids
        # print "[DEBUG] self.label",self.jid,rerun,self.jobids

        # now submit this task if it's submit-able, return the GE jobid and set the self.jid to it
        
        #-------------------- DRMAA START ---------------------#
        # open DRMAA session
        s = _drmaa.Session()
        
        # Start the new session, closing any other sessions first if necessary
        
        try:
            s.initialize()
        except _drmaa.AlreadyActiveSessionException:
            s.exit()
            s.initialize()
            
        # get session data
        session_tag=s.contact
        self.sessionid = session_tag
        

        grid_jids = []
        if self.type:    
            
            if not self.script:
                raise NoFileError("no script set for job:%s" % self.name)
                              
            jt = s.createJobTemplate()
            jt.remoteCommand = self.script
            jt.joinFiles=True            
            jt.workingDirectory=self.wd
            
            if not _os.path.isdir(self.paths['log_path']):
                mkfolder(self.paths['log_path'])
            
            jt.outputPath=":"+self.paths['log_path']
            jt.email=[self.user.email]

            job_env = {}

            for env,val in _os.environ.items():
                if env.endswith('_VERSION') and val != '':
                    job_env[env] = val

            jt.jobEnvironment = job_env
                    
            cpu_str = '1'
            if isinstance(self.cpus,int):
                cpu_str = str(self.cpus)
            elif isinstance(self.cpus,tuple):
                cpu_str = '-'.join(self.cpus)
            
            if self.type is JobType.ARRAY:
            
                # do the frame ranges        
            
                ranges_list=self.frames.split(',')
                
                self.extra_data['frames']=self.frames
                
                for rge in ranges_list:
                    
                    start=int(rge.split('-')[0])
                    end=int(rge.split('-')[-1])
                                    
                    task_info=dict()
                    
                    self.job_names.append( '%s.%s.%s' % (self.label,self.name,rge) )


                    jt.jobName = '%s.%s.%s' % (self.label,self.name,rge)
                    jt.nativeSpecification = ' -S /bin/bash -q %s -w n -shell yes -b no' % self.queue.name
                    jt.nativeSpecification += ' -pe %s %s' % (self.pe.name,cpu_str)
                    jt.nativeSpecification += ' -tc %d' % (self.max_slots)  
                    jt.nativeSpecification += ' -l r_cpu=1'

                    if len(self.envs.keys()):

                        envs_list = []
                        for env,value in self.envs.items():
                            envs_list.append( '%s=%s'%(env,value) )

                        envs_str = ','.join(envs_list)

                        jt.nativeSpecification += ' -v %s' % envs_str

                    if self.resources.has_key('hard') and len(self.resources['hard']):
                        jt.nativeSpecification += ' -hard'
                        for res in self.resources['hard']:
                            jt.nativeSpecification += ' -l %s=%r'%res

                    if self.resources.has_key('soft') and len(self.resources['soft']):
                        jt.nativeSpecification += ' -soft'
                        for res in self.resources['soft']:
                            jt.nativeSpecification += ' -l %s=%r'%res               

                    if self.options:
                        # print self.options
                        jt.nativeSpecification += self.options
                    if self.s_args:
                        jt.args = self.s_args.split()
                        
                    self.jobnames.append(jt.jobName)
                    
                    # set permissions
                    try:
                        _os.chmod(jt.remoteCommand,0775)
                    except OSError,e:
                        print "Warning: could not set permissions on %s"%jt.remoteCommand

                    if len(array_dep_list):
                        jt.nativeSpecification += ' -hold_jid_ad %s' % ','.join(array_dep_list)

                    if len(single_dep_list):
                        jt.nativeSpecification += ' -hold_jid %s' % ','.join(single_dep_list)

                    j_start=int(start)
                    j_end=int(end)
                    j_step=self.step
                    
                    if self.paused:
                        jt.nativeSpecification += ' -h '

                    # Run this job
                    this_jid=s.runBulkJobs(jt,j_start,j_end,j_step)
                    
                    for jid in this_jid:
                    
                        grid_jids.append(jid)
                                               
                        tsk = Task(jid,self)
                        tsk.label = self.label
                        tsk.name = '%s.%s.%s' % (self.label,self.name,rge)
                        tsk.queue = self.queue
                        
                        self.tasks.append(tsk) 

                    self.jid=int(this_jid[-1].split('.')[0])

                    print "== JobId %d sent"%self.jid
                    
                    self.is_submitted = True
                    
            elif self.type == JobType.SINGLE:
                
                
                jt.jobName = '%s.%s' % (self.label,self.name)
                jt.nativeSpecification = ' -S /bin/bash -q %s -w n -shell yes -b no ' % self.queue.name
                jt.nativeSpecification += ' -pe %s %s' % (self.pe.name,cpu_str)
                if self.options:
                    jt.nativeSpecification += self.options
                
                if self.dependency != None and self.dependency not in self.dependency_list: # append the legacy single dependecy if it exists
                    self.dependency_list.append(self.dependency)
                            
                if len(single_dep_list):
                    jt.nativeSpecification += ' -hold_jid %s' % ','.join(single_dep_list)
                        
                if len(self.envs.keys()):

                    envs_list = []
                    for env,value in self.envs.items():
                        envs_list.append( '%s=%s'%(env,value) )

                    envs_str = ','.join(envs_list)

                    jt.nativeSpecification += ' -v %s' % envs_str

                    
                if self.paused:
                    jt.nativeSpecification += ' -h '

                # if self.project:
                #     jt.nativeSpecification += ' -P %s'%self.project
                # print "jt.jobEnvironment %r" % jt.jobEnvironment
                # print "jt.nativeSpecification %r" % jt.nativeSpecification

                this_jid=s.runJob(jt)
                
                grid_jids.append(this_jid)                
                
                tsk = Task(this_jid,self)
                tsk.label = self.label
                tsk.name = '%s.%s' % (self.label,self.name)    
                tsk.queue = self.queue
                
                self.jid=int(this_jid)
                self.tasks.append(tsk)

                self.is_submitted = True
                
                print "== JobId %d sent"%self.jid


                #task_info[jobid[-1][0].split('.')[0]]={"type":self.scripts[sc]['name'],"name":jt.jobName}
                
            s.deleteJobTemplate(jt)
        
        elif self.type == JobType.ROOT:# if this is a root job

            # make the submission python file for this job, for using debugging submissions etc

            root_script = open(self.paths['scripts_path']+"/"+self.label + ".root.%s"%self.dt.strftime('%Y%m%d%H%M%S') +".sh", 'w')
            root_script.write('''#!/bin/bash
#$ -S /bin/bash
#$ -j y
umask 0002

echo %s;

''' % '.'.join([self.label,self.name]))

            root_script.close()

            root_jt = s.createJobTemplate()
            root_jt.remoteCommand = root_script.name # should make a better root comand but for now lets just echo the base job name
            root_jt.joinFiles=True            
            root_jt.workingDirectory=self.wd # why was this commmented before?
            
            if not _os.path.isdir(self.paths['log_path']):
                mkfolder(self.paths['log_path'])
            
            root_jt.outputPath=":"+self.paths['log_path']
            root_jt.email=[self.user.email]

            root_jt.jobName = '%s.%s' % (self.label,self.name)
            root_jt.nativeSpecification = ' -S /bin/bash -q %s -w n -shell yes -b no ' % self.queue.name
            
            # add the child jobs as dependencies, we will need to sort out the hierarchy later
            hold_list = []
            for child in self.children:
                hold_list.append( str(child.jid) )

            if len(single_dep_list): 

                for dep in single_dep_list:
                    hold_list.append( str(dep) )

            root_jt.nativeSpecification += ' -hold_jid %s' % ','.join(hold_list)
            
            if self.paused:
                root_jt.nativeSpecification += ' -h '

            # if self.project:
            #     root_jt.nativeSpecification += ' -P %s'%self.project

            root_jid=s.runJob(root_jt)

            s.deleteJobTemplate(root_jt)
            
            grid_jids.append(root_jid)                
            
            tsk = Task(root_jid,self)
            tsk.label = self.label
            tsk.name = '%s.%s' % (self.label,self.name)    
            tsk.queue = self.queue
            
            self.tasks.append(tsk)        
            self.jid = int(root_jid)

            self.is_submitted = True

            print "== JobId %d sent"%self.jid


                
        for gid in grid_jids:
        
            self.jobids.append( gid )        
            
        #--------------------- DRMAA END ----------------------#
        
        # update the database for the root job
              
        if not self.parent: 

            self.makeSubmissionScript() 
                    
            jobid_smallList = list()
            
            for jid in self.jobids:
                this_jid=None
                
                if isinstance(jid,list):                    
                    this_jid = jid[0].split('.')[0]
                else:
                    this_jid = jid.split('.')[0]
                
                if this_jid not in jobid_smallList:
                    jobid_smallList.append(this_jid)
                           
            jobid_longList = list()
                    
            for jid_long in self.jobids:
                if len(jid_long) > 1 and isinstance(jid_long,list):
                    for jl in jid_long:
                        jobid_longList.append(jl)
                else:
                    jobid_longList.append(jid_long)
        
            if len(jobid_smallList):      

                print 'job ids: %s have been sent to the farm' % str(jobid_smallList)

            ## start-up mysql connection    # TODO: use django database instead
            
            db=_sql_ge.sql_connect()
                    
            table_exists=False
            show_tables = db.query("""SHOW TABLES LIKE 'SHOW_%%'""")
            for table_name in show_tables:
                if table_name.values()[0] == 'SHOW_'+str(self.envs['SHOW']):
                    table_exists=True
                    break
            
            # if not create it based on the template table
            if not table_exists:
                db.execute('''CREATE TABLE IF NOT EXISTS SHOW_%s SELECT * FROM template_show''' % self.envs['SHOW'])
                db.execute('''alter table SHOW_%s modify column id int auto_increment primary key''' % self.envs['SHOW'])
                db.execute('''alter table SHOW_%s modify column submittime timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP''' % self.envs['SHOW'])
                              
            # add to mysql
            list_extra_data=list()
            for key in self.extra_data.keys():list_extra_data.append(':'.join((key,str(self.extra_data[key]))))
            str_extra_data=';'.join(list_extra_data)
            
            # get the current jobid
            
            q = db.query('''SELECT jobcount FROM settings ''')
            sql_id=int(q[0]['jobcount'])
            
            # populate the attributes
            # self.jid=sql_id
            self.jobids=jobid_longList
            self.extra=list_extra_data
            
            # TODO make Task objects fo the job , in the mean time we'll make these dict objects of the job info
            
            job_names = []
            task_info = {}
            
            for child in self.children:
                
                for ch in child.job_names : 
                    job_names.append(ch)
                    
                for tsk in child.tasks:
                    this_id =  tsk.tid.split('.')[0]
                    if not task_info.has_key(this_id):
                        task_info[this_id]=dict()
                        task_info[this_id]['type'] = tsk.label
                        task_info[this_id]['name'] = tsk.name
                        task_info[this_id]['queue'] = tsk.queue
                        # task_info[this_id]['tasks'] = tsk.tasks
                        # task_info[this_id] = vars(tsk)
                        # task_info[this_id]['job'] = dict(tsk.job)
            
            # cater for if this job has no children
            job_names.append(self.name)
            for tsk in self.tasks:
                this_id =  tsk.tid.split('.')[0]
                if not task_info.has_key(this_id):
                    task_info[this_id]=dict()
                    task_info[this_id]['type'] = tsk.label
                    task_info[this_id]['name'] = tsk.name
                    task_info[this_id]['queue'] = tsk.queue
                    # task_info[this_id]['tasks'] = tsk.tasks

                    # task_info[this_id]['job'] = dict(tsk.job)

            self.job_names = ','.join(job_names)
            
            
            # replace the id with plus one
            db.execute('''UPDATE settings SET jobcount = %d WHERE jobcount = %d''' % (int(self.jid)+1,sql_id))

            sql = 'INSERT INTO %s' % 'SHOW_'+self.envs['SHOW']

            sql += ' (id,user,name,type,jobids,wd,logs,session,queue,extra_data,jobnames) VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'
            db.execute(sql,int(self.jid),
                    self.user,
                    self.label+'.'+self.name,
                    self.label,
                    ','.join(self.jobids),
                    self.wd,
                    self.paths['log_path'],
                    str(self.sessionid),
                    self.queue.name,
                    str_extra_data,
                    str(task_info))
            db.close()

            # close drmaa session
            s.exit()
            print "Job.submit(): DRMAA Session Successfully closed"
        
        return self.jobids 

    
    def makeSubmissionScript(self):
        """
        Make a python script that can be used to re-submit this job
        """

        subscript = open(_os.path.join(self.paths['scripts_path'],'%s_%s.py' % (self.label,self.name) ),'w')

        script_text="""#!/usr/bin/env python

from gridengine import *
import os
print version

"""    
        script_text+="from %s import %s\n\n" % (self.__class__.__module__,self.__class__.__name__)
        script_text+="job = %s()\n" % (self.__class__.__name__)
        variables = vars(self)
        for v in sorted(variables):
            if v not in ['children','jobnames','jobids','parent',
                'sessionid','paths','envs','apiVersion','date','dt',
                'extra_data','prefix','submit_host','version'] and variables[v]:

                this_v = variables[v]

                script_text+="job.%s = %r\n" % (v,this_v)

        script_text+="""
job.makeJobs()

job.submit()
"""
        subscript.write(script_text)
        subscript.close()

    def createJobScript(self):
        raise NotImplementedError, "Job.createJobScript()"

    def makeJobs(self):
        raise NotImplementedError, "Job.makeJobs()"

    def checkAttrs(self):
        ''' check if all attributes have a value '''
        return 'TODO'
    
    def reRun(self):
        '''Re-Submit this jobid to gridengine '''
        return 'TODO'
    
    def setScript(self,scriptname):
        self.script=scriptname
            
    def setStart(self,frame):
        self.start=frame
    
    def setEnd(self,frame):
        self.end=frame
    
    def setRange(self,sequence):
        self.frames = sequence
    
    def setStep(self,frame):
        self.step=frame
    
    def setPriority(self,priority):
        self.priority=priority
    
    def setMaxNodes(self):
        return 'TODO'
    
    def setQueue(self,queuename):
        
        self.queue = Queue(queuename)            
        
    def addHost(self,host):
        self.hosts.append(host)
    
    def setHosts(self,hostlist):
        self.hosts.clear()
        for host in hostlist:
            self.addhost(host)
        
    def setWD(self,directory):    
        ''' Set the working directory for this job, this is where the log output will be put'''
        
        self.wd=_os.path.abspath(directory)
        self.paths['log_path']='%s/logs' % self.wd
        self.paths['scripts_path']='%s/scripts' % self.wd
    
    def createWD(self):
        mkfolder(self.wd)
    
    #need to rework this so it returns the scripts environment variables
    def getEnvs(self):
        envs={}


        envs['SHOW']='None'
        envs['USER']=_os.getenv('USER')
        # software related envs
        envs['SOFTWARE']=_os.getenv('SOFTWARE')
        envs['COMPANY']=_os.getenv('COMPANY')
        envs['COMPANY_PATH']=_os.getenv('COMPANY_PATH')
        
        # Workspace related envs
        if _os.getenv('WORKSPACE_PATH'):
            # Old worksapce vairables, will be obsolete, or unecciary to be called
            envs['SHOW']=_os.getenv('SHOW')
            envs['SHOW_PATH']=_os.getenv('SHOW_PATH')
            envs['SCENE']=_os.getenv('SCENE')
            envs['SCENE_PATH']=_os.getenv('SCENE_PATH')
            envs['SHOT']=_os.getenv('SHOT')

            envs['WORKSPACE']=_os.getenv('WORKSPACE')
            envs['WORKSPACE_PATH']=_os.getenv('WORKSPACE_PATH')
            envs['USER_PATH']=_os.path.join(envs['WORKSPACE_PATH'],'user',_os.getenv('USER'))

        else:
            import socket
            hostname = socket.gethostname()
            tmpdir = _os.environ['TMPDIR'] if 'TMPDIR' in _os.environ else '/disk1/tmp'
            envs['WORKSPACE_PATH']=_os.path.join('/net',hostname,tmpdir[1:])
            envs['WORKSPACE']=_os.path.basename(envs['WORKSPACE_PATH'])
            envs['USER_PATH']=_os.path.join(envs['WORKSPACE_PATH'],'user',envs['USER'],'grid_jobs')
    
        # get software versions from the current environment
        # for e,ev in _os.environ.items():
        #     if e.endswith('_VERSION'):
        #         envs[e]=ev
        
        self.envs=envs

    def gettasks(self):
        ''' Return an array of task objects'''
        pass


    def output(self):
        ''' generate job infomation output '''
        
        
        output = "submitting job...: %s \n" % ('.'.join([self.label,self.name]))
        output+= "command..........: %s \n" % self.cmd
        output+= "working dir......: %s \n" % self.wd
        output+= "queue............: %s \n" % self.queue.name
        output+= "parallel env.....: %s %d\n" % (self.pe.name,self.pe.slots)
        output+= "send disabled....: %s \n" % str(self.paused)
        if len(self.dependency_list):
            name_list = []
            for dep in self.dependency_list:
                name_list.append('.'.join([dep.label,dep.name]))
            output+= "depends on.......: %s \n" % ','.join( name_list )
                
        return output
    
    def __iter__(self):
        return iter(eval(str(self)).items())

    def __repr__(self):
        if isinstance(self.jid,int):
            return "%s( %d )"%(self.__module__ + "." + self.__class__.__name__,self.jid)
        else:
            return "%s( '%s' )"%(self.__module__ + "." + self.__class__.__name__,self.name)

    def __str__(self):
        return "%r"%self
